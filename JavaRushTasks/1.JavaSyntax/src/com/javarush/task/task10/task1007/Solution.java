package com.javarush.task.task10.task1007;

/* 
Задача №7 на преобразование целых типов
*/

public class Solution {
    public static void main(String[] args) {
        /*
         1234_564_890L - подчеркивания роли не играют, литера 'L' в конце обозначает, что это long.
         По факту имеем запись (byte)1234564890 - т.е. приводим число 1234567890 к byte,
         как происходит преобразование - переводим 1234567890 в двоичный код (это куча нулей и единиц) и отбрасываем все разряды
         слева кроме последних 8 - по факту получаем число 26.
         */
        long l = 1234_564_890L;      //long l = (byte) 1234_564_890L;
        /*
         (byte)0b1000_1100_1010 - с подчеркиванием тут то же самое, 0b - вначале обозначает,
         что это запись в двоичном коде (только нули и единицы) - без преобразования в  byte имеем число 2250,
         если преобразуем в  byte методом описанным в п.1, то получаем число -54
         */
        int x =  0b1000_1100_1010;    //int x = (byte) 0b1000_1100_1010;
        /*
         (byte)110_987_654_6299.123_34 отбрасываем подчеркивания и получаем по факту double 1109876546299.12334,
         что при приведении к byte будет -1 (почему, я подробно написал в посте к 1ой задаче этого цикла,
         кому интересно, найдете там)
         */
        double m = (byte) 110_987_654_6299.123_34;    //double m = (byte) 110_987_654_6299.123_34;
        /*
        (byte)l++ + 10 + ++x - (float)m - в записи формулы из необычного только ++, но это то же самое,
        что и в цикле, т.е.  увеличиваем переменную просто на 1, но есть особенность - в случае с l++,
        мы сначала делаем операции с l, а только потом ее увеличиваем, а в случае  с ++х, мы сначала увеличиваем х,
        а только потом делаем с ней действия (т.е. в данном случае l++ тут вообще роли ни какой не играет и равно просто l).
         */
        float f =  l++ + 10 + ++x - (float) m;     //float f = (byte) l++ + 10 + ++x - (float) m;
        /*
       Дальше думаю должно быть понятно, что п.2 мы оставляем без изменения т.к. число там выходит за границы диапазона,
       п.1 очень близок к решению если не приводить его в byte, в п.4 тоже понятно, что если привести к byte,
       то получится явно маленькое число. Остается примерно прикинуть как быть с п. 2 - ну это уже не так сложно.
       СПОЙЛЕР( Поэтому просто убираем приведение к (byte) в п.1, п2, п.4. )
         */
        l = (long) f / 1000;     //l = (long) f / 1000;
        System.out.println(l);
    }
}